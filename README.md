# スタック操作

# swap（例：`sa` / `sb` / `ss`）

```bash
操作前: [A, B, C, D]
swap : [B, A, C, D]
```

- 同じスタック内で、先頭２要素の順序だけを入れ替える
- 他の要素は全く動かない
- スタックAを対象にすれば `sa` 、スタックBを対象にすれば `sb`
- 両方同時に行うのが `ss`

# push（例： `pa` / `pb` )

```bash
スタック A: [A1, A2, A3]
スタック B: [B1, B2]

操作:    pa  （「A へ push」。B→A の意味）

結果:
  スタック A: [B1, A1, A2, A3]
  スタック B: [B2]
```

- 異なる2つのスタック間で、先頭要素を「移動」させる。
- 移動元のスタックから先頭を取り除き、移動先のスタックの先頭に差し込む
- `pa` は「BからAに移す」、 `pb` は「AからBに移す」

# Rotate（例： `ra`  / `rb`  / `rr`)

```bash
操作前: [A, B, C, D, …]
rotate : [B, C, D, …, A]
```

- 先頭ノード `A` を切り離す
- 残ったリストの先頭を `B` に更新
- 切り離したノード `A` の `next` を `NULL` にする
- 新しいリスト末尾を探し出し、そこに `A` をつなげる
- `ra` はスタック `A` の先頭ノードを末尾に移動し、2番目以降を前に詰める（ `A` のローテ）
- `rb` はスタック `B` の先頭ノードを末尾に移動し、2番目以降を前に詰める（ `B` のローテ）
- `rr` は `ra` と `rb` を同時に行う

# Reverse Rotate（例：`rra` / `rrb` / `rrr`）

```bash
操作前: [A, B, C, D, …, Z]
reverse: [Z, A, B, C, …, Y]
```

- 最後尾ノード `Z` を探し出す
- 末尾手前ノード `Y` の `next` を `NULL` に切り離す
- `Z->next` に元の先頭 `A` をセット
- `*stack` を `Z` に更新して新先頭にする
- `rra` はスタック `A` の末尾ノードを先頭に移動する（ `A` のリバースローテ）
- `rrb` はスタック `B` の末尾ノードを先頭に移動する（ `B` のリバースローテ）
- `rrr` は `rra` と `rrb` を同時に実行する（ `A` ・ `B` 両方のリバースローテ）

# Radix sort（基数ソート）

```c
void	radix_sort(t_node **stack_a, t_node **stack_b)
{
	int	size;
	int	max_bits;
	int	bit;

	max_bits = get_max_bits(*stack_a);
	bit = 0;
	while (bit < max_bits)
	{
		size = stack_size(*stack_a);
		while (size)
		{
			if (((*stack_a)->rank >> bit) & 1)
				ra(stack_a);
			else
				pb(stack_a, stack_b);
			size--;
		}
		while (*stack_b)
			pa(stack_b, stack_a);
		bit++;
	}
}
```

構造体に `rank` メンバーを追加することで、各ノードが持つ `value` の中身の順位が記録でき、その順位を基数ソートを使ってソートすることで、いくら `value` の値が大きくなろうとも、ソートする回数は増えない。

しかし、ソートするべき値の個数が増えるにつれてソートの回数は増える。

言葉で基数ソートを説明すると

「基数ソートとは、扱う数値をある基数（例：10進数なら 0 ~ 9 ）で桁ごとに振り分け、各パスで安定して再結合することで、完全な昇順を実現するソート」

- 各パスとは？

「ビットごとに振り分けて→元に戻す」下記の１周の動作が１パス

```c
		size = stack_size(*stack_a);
		while (size)
		{
			if (((*stack_a)->rank >> bit) & 1)
				ra(stack_a);
			else
				pb(stack_a, stack_b);
			size--;
		}
		while (*stack_b)
			pa(stack_b, stack_a);
```

基数ソートにおける桁の扱い方

- LSD（Least Significant Digit）：「下位桁 → 上位桁」の順にパスを回す
- MSD（Most Significant Digit）：「上位桁 → 下位桁」の順に分割・再帰を行う

今回のコードではLSDの手法で扱われている

## 例：stack_a [4, 5, 2, 3] の場合  bit = 0

| 値 | 4 →rank = 2(10) | 5 → rank = 3(11) | 2 → rank = 0(00) | 3 → rank = 1(01) |
| --- | --- | --- | --- | --- |
| `rank >> 0` | 10 | 11 | 00 | 01 |
| `(… & 1)` | 0 | 1 | 0 | 1 |
- **4** → (10₂ >> 0) = 10₂ → &1 = 0 (pb) → A: [5, 2, 3] B: [4]
- **5** → (11₂ >> 0) = 11₂ → &1 = 1 (ra) → A: [2, 3, 5] B: [4]
- **2** → (00₂ >> 0) = 00₂ → &1 = 0 (pb) →A: [3, 5] B: [2, 4]
- **3** → (01₂ >> 0) = 01₂ → &1 = 1 (ra) →A: [5, 3] B:[2, 4]
- 

最初にこのような操作が行われる為、それぞれスタックの中身は

Aスタック：[5, 3]

Bスタック：[2, 4]

となる。

そして、paの操作を回すことで、Bスタックの中身をAスタックに戻す

**１回目**

Aスタック：[2, 5, 3]

Bスタック：[4]

**2回目**

Aスタック：[4, 2, 5, 3]

Bスタック：[ ]

こうなり、次のループに移ります（bit = 1)

## bit = 1

| 値 | 4 →rank = 2(10) | 2 → rank = 0(00) | 5 → rank = 3(11) | 3 → rank = 1(01) |
| --- | --- | --- | --- | --- |
| `rank >> 1` | 01 | 00 | 01 | 00 |
| `(… & 1)` | 1 | 0 | 1 | 0 |
- **開始状態**
    
    A: [4, 2, 5, 3]
    
    B: [ ]
    
- **4 → bit1=1 → ra**
    
    A: [2, 5, 3, 4]
    
    B: [ ]
    
- **2 → bit1=0 → pb**
    
    A: [5, 3, 4]
    
    B: [2]
    
- **5 → bit1=1 → ra**
    
    A: [3, 4, 5]
    
    B: [2]
    
- **3 → bit1=0 → pb**
    
    A: [4, 5]
    
    B: [3, 2]
    

### B→A に戻す

1. **pa** → A: [3, 4, 5] B: [2]
2. **pa** → A: [2, 3, 4, 5] B: [ ]

最終的に **A = [2, 3, 4, 5]** となります。


# 実行コマンド
```bash
valgrind --leak-check=full -s -q ./push_swap
```
